<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML>	<HEAD>		<TITLE>Release Hell</TITLE>		<META name="keywords" content="unit test, junit, release hell, release, estimation, how to estimate">		<META name="description" content="Making software development a little more reliable">		<LINK TITLE="House Style" REL=STYLESHEET HREF="../../layout.css" TYPE="text/css">	</HEAD><BODY BGCOLOR="#FFFFFF" onLoad="if (document.searchForm.query) document.searchForm.query.focus()">	<TABLE WIDTH="100%"  cellspacing="0" cellpadding="0">	<TR><!-- TOP BAR WITH SEARCH -->		<TD CLASS="navbar"><a href="/index.html">dallaway.com</a> - <a href="../index.html">Writing</a> - Release Hell</TD><TD class="navbar" VALIGN="middle" ALIGN="right"><!--#include virtual="/findbar.html" --></TD>	</TR>	</TABLE><h1>Making software development a little bit more reliable</h1><p><a href="/contact">Richard Dallaway</a>, June 2004</p><p>All the developers I know hate &quot;last minute releasehell&quot;. This is the frenzy ofactivity that hits when the time comes to release or ship the thing you've beenworking on. A bunch of obscure ordumb problems show themselves, and panic ensues.</p><p>I have no magic bullets to stop this problem from everoccurring, but on a recent project I was struck by the blindingly obvious, andI thought I'd share.</p><h2>Last minute release hell</h2><p>It's bad for everyone. If you're coding, you probably have a manager, and they might have madepromises to other people, marketing have got things booked, and customers havebeen told...there's a lot of pressure on, which makes for a horrible time, fullof grumpy individuals, leading you to day-dream about quitting your job or thesoftware business completely.</p><p>My recent experience of this sort of hell lasted for abouttwo days. The project was goingfairly well, and I was wondering how we'd got ourselves into this position, andthat's when the obvious presented itself:</p><p><i>The part of the code that was causing us pain was thepart with the fewest unit tests.</i></p><p>This might be an obvious statement for you, and indeed itwas for me. However, despiteknowing this information at some level, it was the first time it had become an&quot;observed fact&quot; for me, affecting this particular release beyond all the otherfactors that could be to blame. </p><p>So why didn't we have these unit tests? Because it was an area of code that washard to test. Or rather it was <i>perceived</i>  to be hard to test. I've since gone back and created some tests.It took me about 30 minutes to thinkabout how to create meaningful tests, and about two hours to implement thetests. In doing so I had to changethe code to make it more testable, which almost always leads to a betterdesign. More importantly, codethat was once tainted as being &quot;fragile&quot; and &quot;I don't want totouch that again&quot;, is now restored to first class &quot;no worries&quot;code.</p><p>If we'd put those 2.5 hours in at the beginning, we wouldhave saved two days of headache.If you have any doubts about the utility of unit testing, let me make itsimple: they are worth doing.</p><h2>Making time for tests</h2><p>You barely have time to eat lunch, so how are you going towrite enough tests? Your boss wants the project done by such-and-such a date,and you have to respect that. </p><p>There might be little you can do about this, but there's onething you can try. Unfortunately,it's one of the other things software developers hate...</p><h2>Estimation</h2><p>&quot;When will it be done?&quot;<span style="mso-spacerun:yes">&nbsp;&nbsp; </span>&quot;How long will it take?&quot;</p><p>Many of the developers I know don't like to answer thesequestions. The truth is that it'llbe done once it's done, because that's the only way to know for sure what allthe problems are. Still thequestion will be asked, and it turns out to be a good thing.</p><p>To understand why, recall that scope has a huge effect on aproject. Remove functionality, and you can probably get the job done ontime. This is where estimationcomes into it, because the very best way to help your boss make scope decisionsis to tell them how long things take to do.</p><p>If you hate giving time estimates it might be because you'llget it wrong. Well, you will getit wrong because predicting the future is pretty hard.That's why it's called an&quot;estimate&quot;.There's a big plus side to estimation: by giving estimates you get toinclude the stuff you never have time for, namely unit testing, cleaning up thecrud you left around last time (a.k.a. refactoring), profiling and readingarticles about development. </p><p>The point is that you're a professional, and so to do aprofessional job, you ought to allow for testing and all the other things youneed to do. It's like a builderneeding time to mix cement rather than just skipping ahead to balancing bricksto make a wall. Include thesethings in your estimates.</p><h2>How to estimate</h2><p>I don't know the best way to estimate.Here's one way I've tried, and it seemsto be OK:</p><p>Estimate in ideal programming hours.That's the number of hours to do somethingif there are no disruptions such as deleting email, going to meetings and beinggiven &quot;priority one&quot; tasks that are more &quot;priority one&quot;than all the other &quot;priority one&quot; tasks you're working on.</p><p>Write down the name of some chunk of functionality and listthe things you'll need to do to implement it.Then take a stab at how long it'd take to finish.Three hours for this, an hour here,that's a 14 hour job, and so on. </p><p>With this estimate you can let people know how long it'dtake to get something done, and with this information they can make an informeddecision about which bits of the project they really do want done and which canwait. Remember, though, to turnhours into a date you need to know how many working hours you put into aproject. If you spend half of your working day actually working on thesethings, I suspect you're doing well.Record the hours you do (at the end of the day, just make a quick noteto yourself) and over time you'll get better at doing this, but you'll neverever get it right all the time.Sodon't stress about it.</p><h2>Summary</h2><p>You don't have to be trapped in release hell.Control your time by givingestimates.You'll end up doing abetter job, because you'll have time to include things like unit testing, andyou'll give your team more confidence in your software releases, making yourlife less stressful.</p><h2>Resources</h2><ul><li>Kent Beck &amp; Martin Fowler, <a href="/reading/archive/planxp.xml">Planning Extreme Programming</a>. </li><li>Joel on software, <a href="http://www.joelonsoftware.com/articles/fog0000000245.html">Painless Software Schedules</a>.</li><li><a href="http://junit.org">Junit.org</a>: unit testing frameworks.</li></ul><p>First version June 2004.  This version: $Id: index.html,v 1.1 2004/07/04 10:19:43 richard Exp $</p></BODY></HTML>